<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>y = kx + b 交互演示</title>
    <style>
        :root{--bg:#0b1020;--card:#121932;--muted:#99a3bd;--text:#e9ecf5;--accent:#7aa2ff;--grid:#2a3358;--axis:#e3e8ff;--line:#88e1ff;--point:#ffd166}
        *{box-sizing:border-box}
        body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";background:var(--bg);color:var(--text);}
        .wrap{max-width:980px;margin:auto;padding:32px}
        h1{font-weight:700;letter-spacing:.3px;margin:0 0 16px;font-size:clamp(22px,2.6vw,32px)}
        p.lead{color:var(--muted);margin:.2rem 0 1.2rem}
        .card{background:var(--card);border:1px solid #22305c66;border-radius:18px;box-shadow:0 10px 30px rgba(6,10,30,.35);overflow:hidden}
        .grid{display:grid;grid-template-columns:360px 1fr;gap:0;min-height:520px}
        @media (max-width:900px){.grid{grid-template-columns:1fr;min-height:unset}}
        .panel{padding:20px 22px}
        .panel + .panel{border-left:1px solid #23305b66}
        .row{display:grid;grid-template-columns:120px 1fr;gap:10px;align-items:center;margin:10px 0}
        .row label{color:var(--muted);font-size:14px}
        .row input{width:100%;padding:12px 12px;border-radius:12px;border:1px solid #293560;background:#0f1630;color:var(--text);outline:none}
        .row input:focus{border-color:#3e58ff}
        .btns{display:flex;gap:10px;margin-top:10px}
        button{padding:10px 14px;border-radius:12px;border:1px solid #31408b;background:#172054;color:var(--text);cursor:pointer}
        button:hover{filter:brightness(1.1)}
        .formula{margin-top:14px;font-size:15px}
        .big{font-size:20px}
        .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
        canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#0f1531,#0e1430)}
        .meta{display:flex;gap:14px;flex-wrap:wrap;margin-top:12px;color:var(--muted);font-size:14px}
        .tag{padding:5px 9px;border:1px dashed #2b396e;border-radius:999px}
    </style>
</head>
<body>
<div class="wrap">
    <h1>直线函数：<span class="mono">y = kx + b</span></h1>
    <p class="lead">修改 <span class="mono">k</span>、<span class="mono">b</span> 与 <span class="mono">x</span>，实时计算 <span class="mono">y</span> 并在坐标系中绘制直线与该点。</p>

    <div class="card grid">
        <div class="panel" id="controls">
            <div class="row">
                <label for="k">斜率 k</label>
                <input id="k" type="number" step="any" value="1" />
            </div>
            <div class="row">
                <label for="b">截距 b</label>
                <input id="b" type="number" step="any" value="0" />
            </div>
            <div class="row">
                <label for="x">自变量 x</label>
                <input id="x" type="number" step="any" value="2" />
            </div>
            <div class="btns">
                <button id="reset">重置</button>
                <button id="fit">自适应视图</button>
            </div>
            <div class="formula">
                <div>代入：<span class="mono">y = <span id="kShow">1</span> × x + <span id="bShow">0</span></span></div>
                <div class="big">当 <span class="mono">x = <span id="xShow">2</span></span> 时，<strong>y = <span id="yShow">2</span></strong></div>
            </div>
            <div class="meta">
                <span class="tag">左键拖动平移</span>
                <span class="tag">滚轮缩放</span>
                <span class="tag">双击居中</span>
            </div>
        </div>
        <div class="panel">
            <canvas id="plot" width="900" height="520" aria-label="直线函数绘图"></canvas>
        </div>
    </div>
</div>

<script>
    (() => {
        const $ = (id) => document.getElementById(id);
        const kInput = $("k"), bInput = $("b"), xInput = $("x");
        const kShow = $("kShow"), bShow = $("bShow"), xShow = $("xShow"), yShow = $("yShow");
        const canvas = $("plot");
        const ctx = canvas.getContext("2d");

        // World (math) window
        let world = { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };
        const minSpan = 1e-6;

        // Interaction state
        let dragging = false;
        let last = {x:0, y:0};

        function value(el){
            const v = parseFloat(el.value);
            return Number.isFinite(v) ? v : 0;
        }

        function fmt(n){
            if (!Number.isFinite(n)) return 'NaN';
            const abs = Math.abs(n);
            if (abs !== 0 && (abs < 1e-6 || abs >= 1e6)) return n.toExponential(2);
            const s = Math.round(n * 1e6)/1e6 + '';
            return s;
        }

        function niceStep(raw){
            const p = Math.pow(10, Math.floor(Math.log10(raw)));
            const d = raw / p;
            let m = 1;
            if (d <= 1) m = 1; else if (d <= 2) m = 2; else if (d <= 5) m = 5; else m = 10;
            return m * p;
        }

        function worldToScreen(x, y){
            const {xmin, xmax, ymin, ymax} = world;
            const px = (x - xmin) / (xmax - xmin) * canvas.width;
            const py = (1 - (y - ymin) / (ymax - ymin)) * canvas.height;
            return [px, py];
        }
        function screenToWorld(px, py){
            const {xmin, xmax, ymin, ymax} = world;
            const x = xmin + (xmax - xmin) * (px / canvas.width);
            const y = ymin + (ymax - ymin) * (1 - (py / canvas.height));
            return [x, y];
        }

        function drawGrid(){
            const {xmin, xmax, ymin, ymax} = world;
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0,0,w,h);

            // Grid
            ctx.lineWidth = 1;
            ctx.strokeStyle = getCss('--grid');
            ctx.fillStyle = getCss('--muted');

            const xStep = niceStep((xmax - xmin)/8);
            const yStep = niceStep((ymax - ymin)/8);

            // vertical lines
            let x0 = Math.ceil(xmin / xStep) * xStep;
            for (let x = x0; x <= xmax + 1e-9; x += xStep){
                const [px] = worldToScreen(x, 0);
                ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, h); ctx.stroke();
                // labels
                const [lx, ly] = worldToScreen(x, 0);
                if (Math.abs(x) > 1e-12){ // skip origin label on x-axis; draw near bottom
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.font = '12px ui-sans-serif'; ctx.fillText(fmt(x), lx, h-6);
                }
            }

            // horizontal lines
            let y0 = Math.ceil(ymin / yStep) * yStep;
            for (let y = y0; y <= ymax + 1e-9; y += yStep){
                const [, py] = worldToScreen(0, y);
                ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(w, py); ctx.stroke();
                // labels
                if (Math.abs(y) > 1e-12){
                    ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.font = '12px ui-sans-serif';
                    const [lx, ly] = worldToScreen(0, y);
                    ctx.fillText(fmt(y), 6, ly);
                }
            }

            // axes
            ctx.strokeStyle = getCss('--axis');
            ctx.lineWidth = 1.6;
            // x-axis
            if (ymin < 0 && ymax > 0){
                const [, py] = worldToScreen(0, 0);
                ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(w, py); ctx.stroke();
            }
            // y-axis
            if (xmin < 0 && xmax > 0){
                const [px] = worldToScreen(0, 0);
                ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, h); ctx.stroke();
            }
        }

        function drawLineAndPoint(){
            drawGrid();

            const k = value(kInput), b = value(bInput), x = value(xInput);
            const y = k * x + b;

            // Update formula text
            kShow.textContent = fmt(k); bShow.textContent = fmt(b); xShow.textContent = fmt(x); yShow.textContent = fmt(y);

            const x1 = world.xmin, x2 = world.xmax;
            const y1 = k * x1 + b, y2 = k * x2 + b;

            // Line
            ctx.strokeStyle = getCss('--line');
            ctx.lineWidth = 2.2;
            ctx.beginPath();
            const [p1x, p1y] = worldToScreen(x1, y1);
            const [p2x, p2y] = worldToScreen(x2, y2);
            ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.stroke();

            // Point at (x, y)
            ctx.fillStyle = getCss('--point');
            const [px, py] = worldToScreen(x, y);
            ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fill();

            // Point label
            ctx.font = '13px ui-sans-serif';
            ctx.fillStyle = getCss('--text');
            ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
            ctx.fillText(`(${fmt(x)}, ${fmt(y)})`, px + 8, py - 6);
        }

        function getCss(name){
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || '#fff';
        }

        function fitViewAround(k, b){
            // choose x-range around 0 and the current x; cover both intercept and sample point
            const x = value(xInput);
            let xmin = Math.min(-5, x - 6), xmax = Math.max(5, x + 6);
            if (xmax - xmin < 6) { xmin = x - 3; xmax = x + 3; }
            // include 0 and x
            const candX = [xmin, xmax, 0, x];
            const ys = candX.map(xx => k*xx + b);
            let ymin = Math.min(...ys), ymax = Math.max(...ys);
            if (Math.abs(ymax - ymin) < 4){ ymin -= 2; ymax += 2; }
            // avoid degenerate windows
            if (xmax - xmin < minSpan) xmax = xmin + minSpan;
            if (ymax - ymin < minSpan) ymax = ymin + minSpan;
            world = { xmin, xmax, ymin, ymax };
        }

        function reset(){
            kInput.value = 1; bInput.value = 0; xInput.value = 2;
            world = { xmin: -6, xmax: 6, ymin: -6, ymax: 6 };
            drawLineAndPoint();
        }

        // Mouse interactions
        canvas.addEventListener('mousedown', (e)=>{ dragging = true; last = {x:e.offsetX, y:e.offsetY}; });
        window.addEventListener('mouseup', ()=> dragging = false);
        canvas.addEventListener('mouseleave', ()=> dragging = false);
        canvas.addEventListener('mousemove', (e)=>{
            if (!dragging) return;
            const dx = e.offsetX - last.x;
            const dy = e.offsetY - last.y;
            last = {x:e.offsetX, y:e.offsetY};
            const [wx1, wy1] = screenToWorld(0,0);
            const [wx2, wy2] = screenToWorld(dx, dy);
            const shiftX = wx1 - wx2;
            const shiftY = wy1 - wy2;
            world.xmin += shiftX; world.xmax += shiftX; world.ymin += shiftY; world.ymax += shiftY;
            drawLineAndPoint();
        });

        // Zoom with wheel
        canvas.addEventListener('wheel', (e)=>{
            e.preventDefault();
            const scale = Math.exp(-e.deltaY * 0.001);
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left, py = e.clientY - rect.top;
            const [cx, cy] = screenToWorld(px, py);
            const {xmin, xmax, ymin, ymax} = world;
            const nxmin = cx + (xmin - cx) * scale;
            const nxmax = cx + (xmax - cx) * scale;
            const nymin = cy + (ymin - cy) * scale;
            const nymax = cy + (ymax - cy) * scale;
            world = { xmin: nxmin, xmax: nxmax, ymin: nymin, ymax: nymax };
            drawLineAndPoint();
        }, { passive:false });

        canvas.addEventListener('dblclick', (e)=>{
            const k = value(kInput), b = value(bInput);
            fitViewAround(k, b); drawLineAndPoint();
        });

        // Controls
        for (const el of [kInput, bInput, xInput]){
            el.addEventListener('input', ()=>{ drawLineAndPoint(); });
        }
        $("reset").addEventListener('click', reset);
        $("fit").addEventListener('click', ()=>{ fitViewAround(value(kInput), value(bInput)); drawLineAndPoint(); });

        // Init
        fitViewAround(value(kInput), value(bInput));
        drawLineAndPoint();
    })();
</script>
</body>
</html>
